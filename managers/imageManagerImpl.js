const crypto = require('crypto');
const axios = require('axios');
const process = require('process');

const imageDao = require('../daos/imageDao');
const dockerService = require('../services/dockerService');

/**
 * Retrieves image CVEs from clair.
 * @param imageName
 * @returns {Promise<unknown>}
 */
function getImageCves(imageName) {

  const blobReqOptions = {
    host: process.env.CLAIR_HOSTNAME || 'localhost',  // clair server's hostname
    port: 6060, // clair server's port
    path: 'v1/layers',
    method: 'POST',
    contentType: 'application/json',
  };

  console.log('getting all images where name matches ', imageName);

  return new Promise((resolve, reject) => {
    return imageDao.getImageByName(imageName)
      .then(rows => {
        const layerBlobSum = rows[0][imageDao.CHILD_BLOB_SUM_FIELD];
        return axios.get(`http://${blobReqOptions.host}:${blobReqOptions.port}/${blobReqOptions.path}/${layerBlobSum}?features&vulnerabilities`)
          .then(res => resolve(res.data))
          .catch(err => reject(err));
      })
      .catch(err => reject(err));
  });

}

/**
 * Expects source code repo URI as payload. Builds docker image
 * from source code repo and pushes image to image repo.
 */
function createImage(imageRepoUri, sourceCodeRepoUri, imageTag, username, password) {
  imageTag = imageTag || crypto.randomBytes(8).toString("hex");

  const imageName = sourceCodeRepoUri.substring(sourceCodeRepoUri.lastIndexOf('/') + 1).toLowerCase();
  const imagePath = `${imageRepoUri}/${imageName}:${imageTag}`;

  return new Promise((resolve, reject) => {
    dockerService.login(username, password)
        .then(() => dockerService.buildAndPush(imagePath, sourceCodeRepoUri))
        .catch(err => {
          console.error(err);
        });
    return resolve(imagePath);
  });
}

/**
 * Expects full image repo URI as payload, sends req to Clair
 * for scanning.
 *
 * 1. Expect basic auth in endpoint to send req against registry
 *
 * 2. Pull image from repo to get image layers
 *
 * 3. Filter out duplicate blobsums to get unique layers
 *
 * 4. Submit scan request of image in sequential order
 *
 * 5. Persist a mapping of the image name to bottom-most layer
 */
function processImageForCves(imageRepoUri, imageName, imageTag, bearerToken, username, password) {
  const manifestReqOptions = {
    auth: {username: username, password: password},
    host: imageRepoUri ? imageRepoUri : 'localhost',
    path: `${imageName}/manifests/${imageTag}`,
  };

  const dockerAuthTokenParams = `service=registry.docker.io&scope=repository:${manifestReqOptions.host}/${imageName}:pull`

  axios.get(`https://auth.docker.io/token?${dockerAuthTokenParams}`, {auth: manifestReqOptions.auth})
    .then(dockerAuthRes => {
      const token = dockerAuthRes.data.token;
      console.log("requesting manifest, ", `${manifestReqOptions.host}/${manifestReqOptions.path}`);

      axios.get(`https://registry-1.docker.io/v2/${manifestReqOptions.host}/${manifestReqOptions.path}`, {headers: {Authorization: `Bearer ${token}`}})
        .then(manifestRes => {
          console.log('got manifest from docker ', manifestRes.data);
          onManifestCb(manifestRes.data, token);
        })
        .catch(() => console.error('failed to get manifest'));
    })
    .catch(() => console.error('unable to authenticate ', manifestReqOptions.auth));

  function onManifestCb(manifestRes, token) {
    console.log('callback from manifest req');

    const fsLayers = manifestRes.fsLayers;
    if (fsLayers) {
      const blobSums = fsLayers.map(layer => layer.blobSum);
      const uniqueBlobSums = [...new Set(blobSums)];

      const blobReqOptions = {
        host: process.env.CLAIR_HOSTNAME || 'localhost',  // clair server's hostname
        port: 6060, // clair server's port
        path: 'v1/layers',
        method: 'POST',
        contentType: 'application/json',
      };

      let blobReqs = [];
      for (let i = uniqueBlobSums.length - 1; i >= 0; i--) {
        const uniqueBlobSumName = uniqueBlobSums[i];
        const blobImagePath = `https://registry-1.docker.io/v2/${imageRepoUri}/${imageName}/blobs/${uniqueBlobSumName}`;
        const postData = {
          Layer: {
            Name: uniqueBlobSumName,
            Path: blobImagePath,
            Headers: {
              Authorization: `Bearer ${token}`
            },
            Format: 'Docker',
            ParentName: i === 0 ? "" : uniqueBlobSums[i - 1],
          },
        };

        blobReqs[i] = {
          url: `http://${blobReqOptions.host}:${blobReqOptions.port}/${blobReqOptions.path}`,
          data: postData
        };
      }

      // need to post sequentially in order of image layers
      postSequentially(0)
        .then(insertChildLayerIntoDb)
        .catch(() => console.error('failed to send request to clair'));

      function postSequentially(reqIdx) {
        if (reqIdx >= blobReqs.length) {
          console.log('done with all requests');
          return Promise.resolve();
        }

        console.log('req idx: ', reqIdx, ' posting to: ', blobReqs[reqIdx].url, ' with data: ', blobReqs[reqIdx].data);
        return axios.post(blobReqs[reqIdx].url, JSON.stringify(blobReqs[reqIdx].data))
          .then(() => {
            console.log('success for idx: ', reqIdx, blobReqs[reqIdx].url, blobReqs[reqIdx].data);
            return postSequentially(reqIdx + 1);
          })
          .catch(() => {
            console.error('req failed, skipping this layer with idx: ', reqIdx,  blobReqs[reqIdx].url, blobReqs[reqIdx].data);
            if (reqIdx + 1 < blobReqs.length) {
              // point parent of next idx to this idx's parent
              blobReqs[reqIdx + 1].data.Layer.ParentName = blobReqs[reqIdx].data.Layer.ParentName;
            }
            return postSequentially(reqIdx + 1);
          });
      }

      function insertChildLayerIntoDb() {
        const imageFullName = `${imageRepoUri}/${imageName}:${imageTag}`;

        const image = {};
        image[imageDao.NAME_FIELD] = imageFullName;
        image[imageDao.CHILD_BLOB_SUM_FIELD] = uniqueBlobSums[uniqueBlobSums.length - 1];

        console.log('inserting ', image, ' into db');
        return imageDao.createImage(image);
      }

    }
  }
}

/**
 * Soft deletes an image from the database.
 * @param imageName
 * @returns {Promise<void>}
 */
function deleteImage(imageName) {
  return imageDao.getImageByName(imageName)
    .then(() => imageDao.softDeleteImage(imageName)
      .then(affectedRows => console.log('deleted ', affectedRows, ' rows'))
      .catch(err => console.error(err))
    )
    .catch(() => console.error('no records for image ', imageName, ' found!'));
}

module.exports = {
  getImageCves: getImageCves,
  createImage: createImage,
  processImageForCves: processImageForCves,
  deleteImage: deleteImage,
};
