const crypto = require('crypto');
const axios = require('axios');

// todo have init container to create table if not exists
const imageDao = require('../daos/imageDao');
const dockerService = require('../services/dockerService');

function getImageCves(imageName) {

  //todo host clair
  const blobReqOptions = {
    host: 'localhost',  // clair server's hostname
    port: 6060, // clair server's port
    path: 'v1/layers',
    method: 'POST',
    contentType: 'application/json',
  };

  console.log('getting all images where name matches ', imageName);

  return new Promise((resolve, reject) => {
    return imageDao.getImageByName(imageName)
      .then(rows => {
        const layerBlobSum = rows[0][imageDao.CHILD_BLOB_SUM_FIELD];
        return axios.get(`http://${blobReqOptions.host}:${blobReqOptions.port}/${blobReqOptions.path}/${layerBlobSum}?features&vulnerabilities`)
          .then(res => resolve(res.data))
          .catch(err => reject(err));
      })
      .catch(err => reject(err));
  });

}

/**
 * Expects source code repo URI as payload. Builds docker image
 * from source code repo and pushes image to image repo.
 */
function createImage(imageRepoUri, sourceCodeRepoUri, imageTag, username, password) {
  imageTag = imageTag || crypto.randomBytes(8).toString("hex");

  const imageName = sourceCodeRepoUri.substring(sourceCodeRepoUri.lastIndexOf('/') + 1).toLowerCase();
  const imagePath = `${imageRepoUri}/${imageName}:${imageTag}`;

  return new Promise((resolve, reject) => {
    dockerService.login(username, password)
        .then(() => dockerService.buildAndPush(imagePath, sourceCodeRepoUri))
        .catch(err => {
          console.error(err);
          return reject(err);
        });
    return resolve(imagePath);
  });
}

/**
 * Expects full image repo URI as payload, sends req to Clair
 * for scanning.
 *
 * 1. Expect basic auth in endpoint to send req against registry
 *
 * 2. Pull image from repo to get fslayers
 * -> returns a json with fslayers)
 *
 * 3. Filter out duplicate blobsums to get unique layers (must be sequential)
 *
 * 4. Submit scan request of image: Send post requests to clair in sequential
 * order of layers(A: FROM …; C: CMD …; then send from A->C)
 * Each request if not top layer, should have a reference to parent layer (e.g. B refs A)
 *
 * 5. Persist a mapping of the image name to bottom-most layer
 * (C; reqd when retrieving vulns in Clair’s GET endpoint — GET /layers/:name)
 */
function processImageForCves(imageRepoUri, imageName, imageTag, bearerToken, username, password) {
  const manifestReqOptions = {
    auth: {username: username, password: password},
    host: imageRepoUri ? imageRepoUri : 'localhost',
    path: `${imageName}/manifests/${imageTag}`,
  };

  const dockerAuthTokenParams = `service=registry.docker.io&scope=repository:${manifestReqOptions.host}/${imageName}:pull`

  axios.get(`https://auth.docker.io/token?${dockerAuthTokenParams}`, {auth: manifestReqOptions.auth})
    .then(dockerAuthRes => {
      const token = dockerAuthRes.data.token;
      console.log('got docker auth token');
      console.log("requesting manifest, ", `${manifestReqOptions.host}/${manifestReqOptions.path}`);

      axios.get(`https://registry-1.docker.io/v2/${manifestReqOptions.host}/${manifestReqOptions.path}`, {headers: {Authorization: `Bearer ${token}`}})
        .then(manifestRes => {
          console.log('got manifest from docker ', manifestRes.data);
          onManifestCb(manifestRes.data);
        })
        .catch(() => console.error('failed to get manifest'));
    })
    .catch(() => console.error('unable to authenticate ', manifestReqOptions
    .auth));

  function onManifestCb(manifestRes) {
    console.log('callback from manifest req');

    const fsLayers = manifestRes.fsLayers;
    if (fsLayers) {
      const blobSums = fsLayers.map(layer => layer.blobSum);
      const uniqueBlobSums = [...new Set(blobSums)];

      const blobReqOptions = {
        host: 'localhost',  // clair server's hostname
        port: 6060, // clair server's port
        path: 'v1/layers',
        method: 'POST',
        contentType: 'application/json',
      };

      let blobReqs = [];
      for (let i = uniqueBlobSums.length - 1; i >= 0; i--) {
        const uniqueBlobSumName = uniqueBlobSums[i];
        const blobImagePath = `${manifestReqOptions.host}/v2/${imageName}/blobs/${uniqueBlobSumName}`;
        const postData = {
          Layer: {
            Name: uniqueBlobSumName,
            Path: blobImagePath,
            Headers: {
              Authorization: `Bearer ${bearerToken}`
            },
            Format: 'Docker',
            ParentName: i === 0 ? "" : uniqueBlobSums[i - 1],
          },
        };

        blobReqs[i] = {
          url: `http://${blobReqOptions.host}:${blobReqOptions.port}/${blobReqOptions.path}`,
          data: JSON.stringify(postData)
        };
      }

      // need to post sequentially in order of image layers
      postSequentially(0, 3)
        .then(insertChildLayerIntoDb)
        .catch(() => console.error('failed to send request to clair'));

      function postSequentially(reqIdx, retryCount) {
        if (retryCount <= 0) {
          console.log('max retry count exceeded, aborting');
          return Promise.reject('max retry count exceeded, aborting');
        }

        if (reqIdx >= blobReqs.length) {
          console.log('done with all requests');
          return Promise.resolve();
        }

        return axios.post(blobReqs[reqIdx].url, blobReqs[reqIdx].data)
          .then(() => {
            console.log('success: ', blobReqs[reqIdx].url, blobReqs[reqIdx].data);
            return postSequentially(reqIdx + 1, retryCount);
          })
          .catch(() => {
            console.error('req failed, retrying for...', blobReqs[reqIdx].url, blobReqs[reqIdx].data);
            return postSequentially(reqIdx, retryCount - 1);
          });
      }

      function insertChildLayerIntoDb() {
        const imageFullName = `${imageRepoUri}/${imageName}:${imageTag}`;

        const image = {};
        image[imageDao.NAME_FIELD] = imageFullName;
        image[imageDao.CHILD_BLOB_SUM_FIELD] = uniqueBlobSums[uniqueBlobSums.length - 1];

        console.log('inserting ', image, ' into db');
        return imageDao.createImage(image);
      }

    }
  }
}

function deleteImage(imageName) {
  return imageDao.getImageByName(imageName)
    .then(() => imageDao.softDeleteImage(imageName)
      .then(affectedRows => console.log('deleted ', affectedRows, ' rows'))
      .catch(err => console.error(err))
    )
    .catch(() => console.error('no records for image ', imageName, ' found!'));
}

module.exports = {
  getImageCves: getImageCves,
  createImage: createImage,
  processImageForCves: processImageForCves,
  deleteImage: deleteImage,
};
