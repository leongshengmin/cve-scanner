const crypto = require('crypto');
const axios = require('axios');

const express = require('express');
const router = express.Router();

// todo have init container to create table if not exists
const imageDao = require('../daos/imageDao');
const dockerService = require('../services/dockerService');

router.get('/', (req, res, next) => {

  //todo host clair
  const blobReqOptions = {
    host: 'localhost',  // clair server's hostname
    port: 6060, // clair server's port
    path: 'v1/layers',
    method: 'POST',
    contentType: 'application/json',
  };

  const imageName = req.body.imageName;

  if (!imageName) {
    return res.send({
      message: 'invalid image name',
      status: 400
    });
  }

  console.log('getting all images where name matches ', imageName);

  return imageDao.getImageByName(imageName)
    .then(rows => {
      const layerBlobSum = rows[0][imageDao.CHILD_BLOB_SUM_FIELD];
      return axios.get(`http://${blobReqOptions.host}:${blobReqOptions.port}/${blobReqOptions.path}/${layerBlobSum}?features&vulnerabilities`)
        .then(reportRes => {
          const report = reportRes.data;
          console.log('got report res ', report);
          return res.send(JSON.stringify(report));
        }).catch(err => {
          console.log('error getting report: ', err);
          throw err;
        });
    })
    .catch(err => {
      console.error(err);
      return res.send({
        message: err,
        status: 500
      });
    });

})

/**
 * Expects source code repo URI as payload. Builds docker image
 * from source code repo and pushes image to image repo.
 */
router.post('/', function (req, res, next) {
  let {imageRepoUri, sourceCodeRepoUri, imageTag} = req.body;
  imageTag = imageTag || crypto.randomBytes(8).toString("hex");
  if (!sourceCodeRepoUri || !imageRepoUri) {
    return res.send({
      status: 400,
      message: 'No URI supplied!'
    });
  }

  const imageName = sourceCodeRepoUri.substring(sourceCodeRepoUri.lastIndexOf('/') + 1).toLowerCase();
  const imagePath = `${imageRepoUri}/${imageName}:${imageTag}`;

  const {username, password} = getBasicAuth(req.headers.authorization, res);

  return dockerService.login(username, password)
    .then(() => {
      dockerService.buildAndPush(imagePath, sourceCodeRepoUri);
      return res.send({
        status: 202,
        imagePath: imagePath,
      });
    })
    .catch(err => res.send({ status: 500, message: 'Unable to push image' }));
});

/**
 * Expects full image repo URI as payload, sends req to Clair
 * for scanning.
 *
 * 1. Expect basic auth in endpoint to send req against registry
 *
 * 2. Pull image from repo to get fslayers
 * -> returns a json with fslayers)
 *
 * 3. Filter out duplicate blobsums to get unique layers (must be sequential)
 *
 * 4. Submit scan request of image: Send post requests to clair in sequential
 * order of layers(A: FROM …; C: CMD …; then send from A->C)
 * Each request if not top layer, should have a reference to parent layer (e.g. B refs A)
 *
 * 5. Persist a mapping of the image name to bottom-most layer
 * (C; reqd when retrieving vulns in Clair’s GET endpoint — GET /layers/:name)
 */
router.put('/', (req, res, next) => {
  const {imageRepoUri, imageName, imageTag} = req.body;

  if (!imageName || !imageTag) {
    return res.sendStatus(400);
  }

  const {username, password} = getBasicAuth(req.headers.authorization, res);
  const manifestReqOptions = {
    auth: {username: username, password: password},
    host: imageRepoUri ? imageRepoUri : 'localhost',
    path: `${imageName}/manifests/${imageTag}`,
  };

  const dockerAuthTokenParams = `service=registry.docker.io&scope=repository:${manifestReqOptions.host}/${imageName}:pull`

  console.log('sending req to ', `https://auth.docker.io/token?${dockerAuthTokenParams}`);

  return axios.get(`https://auth.docker.io/token?${dockerAuthTokenParams}`, {auth: manifestReqOptions.auth})
    .then(dockerAuthRes => {
      const token = dockerAuthRes.data.token;
      console.log('got docker auth token');
      console.log("requesting manifest, ", `${manifestReqOptions.host}/${manifestReqOptions.path}`);

      axios.get(`https://registry-1.docker.io/v2/${manifestReqOptions.host}/${manifestReqOptions.path}`, {headers: {Authorization: `Bearer ${token}`}})
        .then(manifestRes => {
          console.log('got manifest from docker ', manifestRes.data);
          onManifestCb(manifestRes.data);
        })
        .catch(() => console.error('failed to get manifest'));

      return res.sendStatus(200);
    })
    .catch(() => res.sendStatus(403));

  function onManifestCb(manifestRes) {
    console.log('callback from manifest req');

    const fsLayers = manifestRes.fsLayers;
    if (fsLayers) {
      const blobSums = fsLayers.map(layer => layer.blobSum);
      const uniqueBlobSums = [...new Set(blobSums)];

      const blobReqOptions = {
        host: 'localhost',  // clair server's hostname
        port: 6060, // clair server's port
        path: 'v1/layers',
        method: 'POST',
        contentType: 'application/json',
      };

      let blobReqs = [];
      for (let i = uniqueBlobSums.length - 1; i >= 0; i--) {
        const uniqueBlobSumName = uniqueBlobSums[i];
        const blobImagePath = `${manifestReqOptions.host}/v2/${imageName}/blobs/${uniqueBlobSumName}`;
        const postData = {
          Layer: {
            Name: uniqueBlobSumName,
            Path: blobImagePath,
            Headers: {
              Authorization: `Bearer ${req.headers.authorization}`
            },
            Format: 'Docker',
            ParentName: i === 0 ? "" : uniqueBlobSums[i - 1],
          },
        };

        blobReqs[i] = {
          url: `http://${blobReqOptions.host}:${blobReqOptions.port}/${blobReqOptions.path}`,
          data: JSON.stringify(postData)
        };
      }

      // need to post sequentially in order of image layers
      postSequentially(0, 3)
        .then(insertChildLayerIntoDb)
        .catch(() => console.error('failed to send request to clair'));

      function postSequentially(reqIdx, retryCount) {
        if (retryCount <= 0) {
          console.log('max retry count exceeded, aborting');
          return Promise.reject('max retry count exceeded, aborting');
        }

        if (reqIdx >= blobReqs.length) {
          console.log('done with all requests');
          return Promise.resolve();
        }

        return axios.post(blobReqs[reqIdx].url, blobReqs[reqIdx].data)
          .then(() => {
            console.log('success: ', blobReqs[reqIdx].url, blobReqs[reqIdx].data);
            return postSequentially(reqIdx + 1, retryCount);
          })
          .catch(() => {
            console.error('req failed, retrying for...', blobReqs[reqIdx].url, blobReqs[reqIdx].data);
            return postSequentially(reqIdx, retryCount - 1);
          });
      }

      function insertChildLayerIntoDb() {
        const imageFullName = `${imageRepoUri}/${imageName}:${imageTag}`;

        const image = {};
        image[imageDao.NAME_FIELD] = imageFullName;
        image[imageDao.CHILD_BLOB_SUM_FIELD] = uniqueBlobSums[uniqueBlobSums.length - 1];

        console.log('inserting ', image, ' into db');
        return imageDao.createImage(image);
      }

    }
  }
})

function getBasicAuth(authHeaders, res) {
  const base64Credentials = authHeaders.split(' ')[1];
  const credentials = Buffer.from(base64Credentials, 'base64').toString('ascii');
  const [username, password] = credentials.split(':');
  if (!username || !password) {
    return res.send({
      status: 400,
      message: `No Creds supplied!`
    })
  }
  return { username, password };
}

module.exports = router;
