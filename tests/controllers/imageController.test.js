const imageController = require("../../controllers/imageController");
const imageManager = require("../../managers/imageManagerImpl");
const dbConnectorSvc = require('../../services/dbConnectorService');
const sinon = require('sinon') ;

afterEach(() => dbConnectorSvc.destroy());

describe("createImage()", () => {

  it("no URI should return 400", () => {

    const expectedResp = {
      status: 400,
      message: 'No URI supplied!'
    };
    const data = imageController.createImage(
      mockRequest("", "", "", "", ""),
      mockResponse(expectedResp)
    );

    expect(data).toBeDefined();
    expect(data.message).toBe(expectedResp.message);
    expect(data.status).toBe(expectedResp.status);

  });

  it("no authorization header should return 403", () => {

    const expectedResp = {
      status: 403,
      message: 'No auth header sent with request!'
    };
    const data = imageController.createImage(
      mockRequest("", "imageRepoUri", "sourceCodeRepoUri", "", ""),
      mockResponse(expectedResp)
    );

    expect(data).toBeDefined();
    expect(data.message).toBe(expectedResp.message);
    expect(data.status).toBe(expectedResp.status);
  });

  it("happy path", () => {

    sinon.stub(imageManager, 'createImage').callsFake(() => Promise.resolve("imagepath"));
    const expectedResp = {
      status: 201,
      data: {
        imagePath: "imagepath"
      }
    };

    const imageManagerSpy = jest.spyOn(imageManager, 'createImage');

    imageController.createImage(
      mockRequest("bearer token", "imageRepoUri", "sourceCodeRepoUri", ""),
      mockResponse(expectedResp)
    );
    expect(imageManagerSpy).toBeCalled();

  });
});

describe("getImageCves()", () => {

  it("invalid image name should return 400", () => {

    const expectedResp = {
      status: 400,
      message: 'Invalid image name'
    };
    const data = imageController.getImageCves(
      mockRequest("", "", "", "", ""),
      mockResponse(expectedResp)
    );

    expect(data).toBeDefined();
    expect(data.message).toBe(expectedResp.message);
    expect(data.status).toBe(expectedResp.status);
  });

  it("happy path", () => {

    sinon.stub(imageManager, 'getImageCves').callsFake(() => Promise.resolve({"cves": []}));
    const expectedResp = {
      status: 200,
      data: {
        "cves": []
      }
    };

    const imageManagerSpy = jest.spyOn(imageManager, 'getImageCves');

    imageController.getImageCves(
      mockRequest("", "", "", "", "imageName"),
      mockResponse(expectedResp)
    );
    expect(imageManagerSpy).toBeCalled();

  });
});

describe("processImageForCves()", () => {

  it("invalid image name or tag should return 400", () => {

    const expectedResp = {
      status: 400,
      message: 'Invalid image name or tag'
    };
    const allEmpty = imageController.getImageCves(
      mockRequest("", "", "", "", ""),
      mockResponse(expectedResp)
    );

    expect(allEmpty).toBeDefined();
    expect(allEmpty.message).toBe(expectedResp.message);
    expect(allEmpty.status).toBe(expectedResp.status);

    const someEmpty = imageController.getImageCves(
      mockRequest("", "lej", "", "ojr", ""),
      mockResponse(expectedResp)
    );

    expect(someEmpty).toBeDefined();
    expect(someEmpty.message).toBe(expectedResp.message);
    expect(someEmpty.status).toBe(expectedResp.status);
  });

  it("no authorization header should return 403", () => {

    const expectedResp = {
      status: 403,
      message: 'No auth header sent with request!'
    };
    const data = imageController.processImageForCves(
      mockRequest("", "imageRepoUri", "sourceCodeRepoUri", "", ""),
      mockResponse(expectedResp)
    );

    expect(data).toBeDefined();
    expect(data.message).toBe(expectedResp.message);
    expect(data.status).toBe(expectedResp.status);
  });

  it("happy path", () => {

    sinon.stub(imageManager, 'processImageForCves').callsFake(() => Promise.resolve());

    const expectedResp = {
      status: 200,
    };
    const mockedResp = mockResponse(expectedResp);
    mockedResp.sendStatus = jest.fn().mockReturnValue(expectedResp.status);

    const imageManagerSpy = jest.spyOn(imageManager, 'processImageForCves');

    const resp = imageController.processImageForCves(
      mockRequest("bearer token", "ffe", "", "fegr", "imageName"),
      mockedResp
    );
    expect(imageManagerSpy).toBeCalled();
    expect(resp).toBe(200)

  });
});

describe("deleteImage()", () => {

  it("invalid image name should return 400", () => {

    const expectedResp = {
      status: 400,
      message: 'No image name supplied!'
    };
    const data = imageController.deleteImage(
      mockRequest("", "", "", "", ""),
      mockResponse(expectedResp)
    );

    expect(data).toBeDefined();
    expect(data.message).toBe(expectedResp.message);
    expect(data.status).toBe(expectedResp.status);
  });

  it("happy path", () => {

    sinon.stub(imageManager, 'deleteImage').callsFake(() => Promise.resolve());
    const expectedResp = {
      status: 202
    };
    const mockedResp = mockResponse(expectedResp);
    mockedResp.sendStatus = jest.fn().mockReturnValue(expectedResp.status);

    const imageManagerSpy = jest.spyOn(imageManager, 'deleteImage');

    const resp = imageController.deleteImage(
      mockRequest("", "", "", "", "imageName"),
      mockedResp
    );
    expect(imageManagerSpy).toBeCalled();
    expect(resp).toBe(expectedResp.status);

  });
});

let mockResponse = (retVal) => {
  const res = {};
  res.send = jest.fn().mockReturnValue(retVal);
  return res;
};

let mockRequest = (bearerToken, imageRepoUri, sourceCodeRepoUri, imageTag, imageName) => {
  return {
    headers: {
      authorization: bearerToken
    },
    body: {
      imageRepoUri: imageRepoUri,
      sourceCodeRepoUri: sourceCodeRepoUri,
      imageTag: imageTag,
      imageName: imageName
    },
  };
};
